{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf160
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fmodern\fcharset0 Courier;\f2\fnil\fcharset0 LucidaGrande;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red56\green57\blue62;\red240\green245\blue249;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid2\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\paperw11900\paperh16840\margl1440\margr1440\vieww18160\viewh14120\viewkind0
\deftab720
\pard\pardeftab720

\f0\b\fs22 \cf2 \cb3 \expnd0\expndtw0\kerning0
CT20A6400 - LANGUAGES, COMPILERS AND INTERPRETERS - PASCAL COMPILER PROJECT\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
Original by Kari Jyrkinen, modified by Jarmo Ilonen, Arto Kaarna.\
Practical assignment for the course in spring 2008.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
Changes, comments, solutions, hints, notifications...\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0
\b0 \cf2 \cb1 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(2.5.2008) Those who are working with the pcs-package, please note the following:\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440
\ls1\ilvl1\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
Keep the code in the files: do not modify or remove that. If a code is missing or it is not correct, the assignment based on pcs cannot be accepted. The code is inserted as a comment in the files, it does not affect to the compilation or any other actions with the files.\
\ls1\ilvl1\kerning1\expnd0\expndtw0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
To generate code for an expression like a = b+c: 
\f1 \expnd0\expndtw0\kerning0
        | expr '+' expr                 \{$$=tacind(gettemp()); makequad(TAC_ADD,$1,$3,$$);\}\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440
\ls1\ilvl1\cf2 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\uc0\u8232 
\f0 \expnd0\expndtw0\kerning0
This info is slighly different from the one lower in this page. In this pcs-package TAC codes are like TAC_ADD b,c,a. See file pcs.c function makequad.\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(9.4.2008) Check "Error handling" section below: the goal is to parse all statements in the source code.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(9.4.2008) Write a parser that recognizes the tokens for syntax analysis and then informs the user about the errors in the source code. Use Bison practices in reporting those syntax errors. See {\field{\*\fldinst{HYPERLINK "http://www.gnu.org/software/bison/manual/pdf/bison.pdf"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul Bison manual}}, page 83... for examples.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(4.3.2008) {\field{\*\fldinst{HYPERLINK "http://www.gnu-pascal.de/gpc/index.html"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul Gnu Pascal Manual}}\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(25.3.2008) Status of assignments ({\field{\*\fldinst{HYPERLINK "http://www.it.lut.fi/kurssit/07-08/CT20A6400/osallistujat.pdf"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul pdf file}}, last update 28.3.2008). From now on, see page {\field{\*\fldinst{HYPERLINK "http://www.it.lut.fi/kurssit/07-08/CT20A6400/projects.html"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul projects}} for the status of the assignment.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(1.2.2008) Read the given description, participate in a group of two students, agree the timetable (with given absolute deadlines), allocate the tasks, and start to work on the assignment. Some of the very late exercises will still support the work for the assignment.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(29.1.2008) None so far.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
Overall description\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
Write a Pascal compiler, which compiles simple Pascal programs to executable machine code. Only limited features of the Pascal language have to be implemented. A short introduction to the language can be found in Wikipedia, {\field{\*\fldinst{HYPERLINK "http://en.wikipedia.org/wiki/Pascal_%28programming_language%29"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul here}}. The actual standard is available here, {\field{\*\fldinst{HYPERLINK "http://www.pascal-central.com/docs/iso7185.pdf"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul ISO-7185}}.\
The ANSI C standard is usually strictly followed, but I've tried to simplify some things. If something is not defined, you can follow the standard - or ask me. A good book in English is <i>Brian W. Kerningham, Dennis M. Richie: The C programming language (ANSI C)</i>.\
The compiler has to be implemented using C programming language and with the help of 
\i \expnd0\expndtw0\kerning0
flex
\i0 \expnd0\expndtw0\kerning0
 and 
\i \expnd0\expndtw0\kerning0
bison
\i0 \expnd0\expndtw0\kerning0
. The parser should produce 
\i \expnd0\expndtw0\kerning0
three-address code (TAC)
\i0 \expnd0\expndtw0\kerning0
, which will be translated to assembler and compiled using the GNU '
\f1 \expnd0\expndtw0\kerning0
as
\f0 \expnd0\expndtw0\kerning0
' compiler. Your compiler should produce ELF executable code for the IA-32 architecture (Intel x86 architecture).\
The file containing the Pascal source code have an ending 
\i \expnd0\expndtw0\kerning0
.p
\i0 \expnd0\expndtw0\kerning0
 (f. ex. 
\i \expnd0\expndtw0\kerning0
code.p
\i0 \expnd0\expndtw0\kerning0
) and an executable file having the same name - but without the ending - have to be generated to a file named (
\i \expnd0\expndtw0\kerning0
code
\i0 \expnd0\expndtw0\kerning0
). Assembler code will be written into a file having an ending 
\i \expnd0\expndtw0\kerning0
.s
\i0 \expnd0\expndtw0\kerning0
 (
\i \expnd0\expndtw0\kerning0
code.s
\i0 \expnd0\expndtw0\kerning0
). Calling the assembler in your C code can be done using 
\i \expnd0\expndtw0\kerning0
system
\i0 \expnd0\expndtw0\kerning0
 function. Your compiler must be able to be used in this way:\
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
$ ./
\f3\i \expnd0\expndtw0\kerning0
my_compiler
\f1\i0 \expnd0\expndtw0\kerning0
 code.p\uc0\u8232 $ ./code
\f0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
The syntax\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
Programs to be compiled consist only of a main function. Function declarations and definitions are not required to be implemented. All variables are global and they are introduced before the executable statements in the main function.\
Basic pascal program structure:
\f1 \expnd0\expndtw0\kerning0
\
        program TITLE ( input, output );\
	var ( *Variable declarations *)\
        begin\
	  (* Main function, which can consist of statements. *)\
        end.\

\f0 \expnd0\expndtw0\kerning0
TITLE is the program file name without the .p-ending. Input or output are, in fact, required only if input or output actions are used, but you can require those keywords in all accepted programs. Blocks start with 
\b \expnd0\expndtw0\kerning0
begin
\b0 \expnd0\expndtw0\kerning0
 and end with 
\b \expnd0\expndtw0\kerning0
end
\b0 \expnd0\expndtw0\kerning0
, and the block containing the whole program ends with 
\b \expnd0\expndtw0\kerning0
end.
\b0 \expnd0\expndtw0\kerning0
 (note the dot as the last character).\
\
The return value of the main function is an integer and no input arguments are taken. Instead of empty parentheses <span style="font-style: italic;">void</span> is required. A <span style="font-style: italic;">return</span> statement is not obligatory, for the program may end when the last statement is executed. The structure of the programs is this: <blockquote> <pre>[variable definitions]<br><br>int main (void)<br>\{<br> [variable definitions]<br> [program statements]<br>\}</pre> </blockquote> The parts in brackets may be left out.</p>
\b \expnd0\expndtw0\kerning0
\
Comments and 'white spaces'\

\b0 \expnd0\expndtw0\kerning0
Pascal comments have to be implemented ( 
\i \expnd0\expndtw0\kerning0
\{this is a comment\}
\i0 \expnd0\expndtw0\kerning0
, 
\i \expnd0\expndtw0\kerning0
(* and so is this *)
\i0 \expnd0\expndtw0\kerning0
 ) - nested comments are not allowed. Spaces, tabs and newlines are characters, which can be ignored in the lexer. White space is required to separate otherwise adjacent identifiers, keywords and constants, though. "If a symbol, which starts by letter or digit, is followed by a symbol, which also starts by letter or digit, then there must be at least one space between them." (Korpela & Larmela)\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Identifiers\
\pard\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
An identifier must be declared before it can be used, otherwise an error message is printed during compilation. Only one data type has to be implemented, integer number 
\i \expnd0\expndtw0\kerning0
integer
\i0 \expnd0\expndtw0\kerning0
.\
Identifiers begin with a letter, then followed by any digit, letter or the underscore character ( _ ). Pascal is case-insensitive: variable, VARIABLE and variABLE are same identifiers. When you use flex with flag 
\i \expnd0\expndtw0\kerning0
-i
\i0 \expnd0\expndtw0\kerning0
, it produces case-insensitive scanner. Value in yytext will be unchanged, so change that to lower case. Start labels and temporary variables with underscore so that they don't interfere with normal variables. The length of variable names can be restricted to 8 characters.\
Keywords / reserved words can not be used as variable names. A declaration line is of form "
\f1 \expnd0\expndtw0\kerning0
var foo, bar, baz:integer;
\f0 \expnd0\expndtw0\kerning0
", i.e., they consist of reserved word "var" followed by comma-separated list of variable names, and ending with a colon and the variable type. Initializing the variables is not necessary to be implemented in this stage. According to the standard the value of an uninitialized global integer variable is zero. This initialization can be easily done when generating assembler.\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Integer and character constants\
\pard\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
Integer constants mean normal integer numbers, which are used f. ex. in calculations, assignments and comparisons. Basic arithmetric operations are (+,-,*,DIV). DIV is used for integer divisions instead of '/' which is reserved for divisions with floating point numbers. A string constant is marked as 
\i \expnd0\expndtw0\kerning0
'x'
\i0 \expnd0\expndtw0\kerning0
 and can be used for output.\
and it means the ASCII code of the character surrounded by inverted commas. So operations like these are acceptable:</p> <p> charvar = 'Z';<br> intvar = 3 * 'g' + 'A';<br> </p> <p>In the other words, you can return character constants as a number in having the ASCII code as its value.</p>
\b \expnd0\expndtw0\kerning0
\
Keywords\

\b0 \expnd0\expndtw0\kerning0
Keywords, which your compiler should recognice, are: 
\b \expnd0\expndtw0\kerning0
program, var, begin, end, integer, if, then, else, while, do, repeat, until
\b0 \expnd0\expndtw0\kerning0
. Function names 
\b \expnd0\expndtw0\kerning0
write
\b0 \expnd0\expndtw0\kerning0
 and 
\b \expnd0\expndtw0\kerning0
writeln
\b0 \expnd0\expndtw0\kerning0
 can be handled like keywords. Keywords may not be variable names in Pascal language. Note that using a token 
\b \expnd0\expndtw0\kerning0
BEGIN
\b0 \expnd0\expndtw0\kerning0
 for keyword 
\b \expnd0\expndtw0\kerning0
begin
\b0 \expnd0\expndtw0\kerning0
 is not a good idea because lex uses BEGIN for changing between starting conditions.\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Statements and sentences\
Statements
\b0 \expnd0\expndtw0\kerning0
 to be implemented are 
\i \expnd0\expndtw0\kerning0
assignment, write and writeln statements, if-then-else statement, while and repeat loops, and an empty statement
\i0 \expnd0\expndtw0\kerning0
. All statements end with a semicolon - except that the last statement in a block (inside 
\f1 \expnd0\expndtw0\kerning0
begin ... end
\f0 \expnd0\expndtw0\kerning0
) does not require a semicolon, but it can still be there. In the Pascal programming language 
\b \expnd0\expndtw0\kerning0
a sentence
\b0 \expnd0\expndtw0\kerning0
 can be 
\i \expnd0\expndtw0\kerning0
an expression
\i0 \expnd0\expndtw0\kerning0
 or 
\i \expnd0\expndtw0\kerning0
a comparison
\i0 \expnd0\expndtw0\kerning0
 (in fact anything, which returns a value) - we'll make a difference between these, though: I use expression or comparison later on. Comparisons are used in 
\i \expnd0\expndtw0\kerning0
if
\i0 \expnd0\expndtw0\kerning0
, 
\i \expnd0\expndtw0\kerning0
while
\i0 \expnd0\expndtw0\kerning0
 and 
\i \expnd0\expndtw0\kerning0
repeat
\i0 \expnd0\expndtw0\kerning0
 statements.\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
variable := expression
\i0 \expnd0\expndtw0\kerning0
\

\f1 \expnd0\expndtw0\kerning0
write
\f0\i \expnd0\expndtw0\kerning0
('string' | integer )
\i0 \expnd0\expndtw0\kerning0
\

\f1 \expnd0\expndtw0\kerning0
writeln
\f0\i \expnd0\expndtw0\kerning0
('string' | integer )
\i0 \expnd0\expndtw0\kerning0
\

\f1 \expnd0\expndtw0\kerning0
if
\f0\i \expnd0\expndtw0\kerning0
 comparison_is_true 
\f1\i0 \expnd0\expndtw0\kerning0
then
\f0 \expnd0\expndtw0\kerning0
 
\i \expnd0\expndtw0\kerning0
statement1 [
\f1\i0 \expnd0\expndtw0\kerning0
else
\f0 \expnd0\expndtw0\kerning0
 
\i \expnd0\expndtw0\kerning0
statement2]
\i0 \expnd0\expndtw0\kerning0
\

\f1 \expnd0\expndtw0\kerning0
repeat
\f0\i \expnd0\expndtw0\kerning0
 statement 
\f1\i0 \expnd0\expndtw0\kerning0
until
\f0 \expnd0\expndtw0\kerning0
 
\i \expnd0\expndtw0\kerning0
comparison_is_true
\i0 \expnd0\expndtw0\kerning0
\

\f1 \expnd0\expndtw0\kerning0
while
\f0\i \expnd0\expndtw0\kerning0
 comparison_is_true
\i0 \expnd0\expndtw0\kerning0
 
\f1 \expnd0\expndtw0\kerning0
do
\f0 \expnd0\expndtw0\kerning0
 
\i \expnd0\expndtw0\kerning0
statement
\i0 \expnd0\expndtw0\kerning0
\

\i \expnd0\expndtw0\kerning0
expression
\i0 \expnd0\expndtw0\kerning0
\

\i \expnd0\expndtw0\kerning0
;
\i0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
An assignment
\b0 \expnd0\expndtw0\kerning0
 consists of a variable on the left hand side and an expression on the right side. An expression can be also a plain variable or a number\

\b \expnd0\expndtw0\kerning0
write
\b0 \expnd0\expndtw0\kerning0
 leaves the cursor at the end of the output, 
\b \expnd0\expndtw0\kerning0
writeln
\b0 \expnd0\expndtw0\kerning0
 prints also newline. They can take several parameters in Pascal, but you can write a compiler which accepts only one parameter.\
Parentheses are not required around relational/logical expressions in Pascal, but they can be there like in all expressions.\
The statement which follows 
\b \expnd0\expndtw0\kerning0
if/then/else
\b0 \expnd0\expndtw0\kerning0
 or 
\b \expnd0\expndtw0\kerning0
while
\b0 \expnd0\expndtw0\kerning0
 can be a single statement or a block. Blocks are surrounded by keywords 
\b \expnd0\expndtw0\kerning0
begin
\b0 \expnd0\expndtw0\kerning0
 and 
\b \expnd0\expndtw0\kerning0
end
\b0 \expnd0\expndtw0\kerning0
 and they consist of a list of statements - control structures and blocks are allowed, too. There can always be several statements between 
\b \expnd0\expndtw0\kerning0
repeat
\b0 \expnd0\expndtw0\kerning0
 and 
\b \expnd0\expndtw0\kerning0
until
\b0 \expnd0\expndtw0\kerning0
, even without explicit begin/end block. Remember that a statement can be an empty statement and a list of statements can be only one statement, which can be an empty statement. An 
\b \expnd0\expndtw0\kerning0
else
\b0 \expnd0\expndtw0\kerning0
 part in the 
\b \expnd0\expndtw0\kerning0
if/then
\b0 \expnd0\expndtw0\kerning0
 statement is not obligatory.\
Comparison expressions follow the structure 
\i \expnd0\expndtw0\kerning0
expression comparison_operator expression 
\i0 \expnd0\expndtw0\kerning0
and comparison operators can be >, >=, <, <=, = and <>, f. ex. 
\i \expnd0\expndtw0\kerning0
variable + 1 <> 5 * i2
\i0 \expnd0\expndtw0\kerning0
.\
A sentence in <i>for</i> statements can be assignment, expression, print command or empty. <span style="font-style: italic;">For</span> statement can be written using while as follows:</p> <blockquote> <blockquote> <pre>sentence1;<br>while (comparison)<br>\{<br> statement;<br> sentence2;<br>\}<br></pre> </blockquote> </blockquote> <p><b>Return statement</b> returns result of an expression, value of a variable or integer constant - the expression part may be left away, too.\
The basic arithmetic operations are addition, subtraction, multiplication and division. Terms can be grouped using parenthesis. Unary minus can be used, but there's no unary plus in the Pascal programming language. The precedence of operators is this:\
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
()				left to right\
*, DIV				left to right\
+, -				left to right\
\pard\pardeftab720

\f0 \cf2 \expnd0\expndtw0\kerning0
You don't need any precedence rules for comparison operators because only one comparison is accepted in our grammar. The precedence of comparisons is lower than any of the mathematical operators.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
An example of acceptable code\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
The following code using most of the required features of the language should be accepted and compiled by your compiler. It may not be a good idea to use the whole code for testing when programming your compiler but divide it into smaller parts, or just use small self-written programs for testing.
\f1 \expnd0\expndtw0\kerning0
\
\{an example of Pascal code\}\
\
program example ( input, output );\
var value1 : integer;\
    value2 : integer;\
begin\
   (* this is a\
    * multiline comment *)\
   value1:=10;\
   value2:=3*value1 DIV (1+1)-4;\
\
   write('Value1 is: ');\
   writeln(value1);\
   write('Value2 is: ');\
   writeln(value2);\
\
   if value1<>value2 then\
   begin\
      writeln('Values were not same.');\
      value1:=value2;\
   end;\
\
   while value1>1 do\
   begin\
      value1:=value1-1;\
      writeln(value1)\
   end;\
\
   repeat\
      value2:=value2-1;\
      writeln(value2)\
   until value1=value2;\
\
   if value1=value2 then\
      writeln('Values are same.')\
   else\
      writeln('Values are not same.');\
\
end.\

\f0 \expnd0\expndtw0\kerning0
The code can be downloaded from {\field{\*\fldinst{HYPERLINK "http://www.it.lut.fi/kurssit/07-08/CT20A6400/example.p"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul example.p}}.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
Symbol table and generation of TAC\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
You need a symbol table to store the declared variables, the string literals used with 
\i \expnd0\expndtw0\kerning0
write/writeln
\i0 \expnd0\expndtw0\kerning0
 also have to be stored somewhere. A static table is enough, but a hash table or a linked list can be used as a symbol table. A linked list is not so often used in practice, because a static table is faster. The values of the variables are not added to the symbol table, because they are calculated at runtime of the program. Different kind of parameters may be stored in different symbol tables, or in one symbol table with additional field holding the type of each element in the symbol table.\
TAC instruction and its arguments can be stored into a structure and the structures into a linked list. The structure may look something like this:\
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
struct tac\
\{ \
int operation;; \
struct tacarg a; \
struct tacarg b; \
struct tacarg c;\
\}\
\pard\pardeftab720

\f0 \cf2 \expnd0\expndtw0\kerning0
Arguments can be structures, pointers to the symbol table or something else. If you use separate argument structures, they may look like this:\
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
struct tacarg\
\{\
	int argumentype;\
	union\
	\{\
		int		number; 	/* Integer constants */\
		struct symtab 	*symbol;	/* Identifiers */\
		char		*label;		/* Labels */\
	\} argument;\
\}\
\pard\pardeftab720

\f0 \cf2 \expnd0\expndtw0\kerning0
All actions are presented using TAC. The following TAC instructions should be enough to generate the intermediate code:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Binary operations: 
\f1 \expnd0\expndtw0\kerning0
	a := b + c			(TAC_ADD,a,b,c)\uc0\u8232 	a := b - c			(TAC_SUB,a,b,c)\u8232 	a := b * c			(TAC_MUL,a,b,c)\u8232 	a := b / c			(TAC_DIV,a,b,c)\u8232 
\f0 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Unary operation (probably useless in this project): 
\f1 \expnd0\expndtw0\kerning0
	a := -b				(TAC_UM,a,b,NULL)\uc0\u8232 
\f0 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Assignment: 
\f1 \expnd0\expndtw0\kerning0
        a := b          		(TAC_AS,a,b,NULL)
\f0 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Label: 
\f1 \expnd0\expndtw0\kerning0
        label a                         (TAC_LBL,a,NULL,NULL)
\f0 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Unconditional jump: 
\f1 \expnd0\expndtw0\kerning0
        goto a         			(TAC_JMP,a,NULL,NULL)
\f0 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Conditional jumps: 
\f1 \expnd0\expndtw0\kerning0
        if a less b goto c		(TAC_JL,a,b,c)\uc0\u8232         if a greater b goto c		(TAC_JG,a,b,c)\u8232         if a less or equal b goto c	(TAC_JLE,a,b,c)\u8232         if a greater of equal b goto c	(TAC_JGE,a,b,c)\u8232         if a equal b goto c		(TAC_JE,a,b,c)\u8232         if a not equal b goto c		(TAC_JNE,a,b,c)\u8232 
\f0 \expnd0\expndtw0\kerning0
\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Output: 
\f1 \expnd0\expndtw0\kerning0
	arg a				(TAC_ARG,a,NULL,NULL)\uc0\u8232 	arg b				(TAC_ARG,b,NULL,NULL)\u8232 	...\u8232         call printf			(TAC_PR,NULL,NULL,NULL)\u8232 
\f0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
TAC_RET
\f0 \expnd0\expndtw0\kerning0
, 
\f1 \expnd0\expndtw0\kerning0
TAC_DEC
\f0 \expnd0\expndtw0\kerning0
 ja 
\f1 \expnd0\expndtw0\kerning0
TAC_INC
\f0 \expnd0\expndtw0\kerning0
 may be used as TAC instructions, too. You also need temporary identifiers, which have to be added to the symbol table, and labels for jumps. Start labels and temporary identifiers with underscore so that they don't interfere so easily with normal variables.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
Error handling\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
If your compiler finds and error, an error message and the line number, where the error was, should be printed. If you want, you can add a counter to how many errors are found. A reasonable solution is to try go through the whole source program and to try to find all syntax errors in that. This requires error recovery. Check Bison manual for its possibilities in error recovery, and the exercises on week 10.\
Another solution would be to limit the parsing until some number of errors are found, e.g. 5.\
Naturally, the assembly code shouldn't be generated, if there were errors in the program code.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
Generation of assembly code\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
The assembly code is generated into a file with the same name as the source code but with an ending 
\i \expnd0\expndtw0\kerning0
.s
\i0 \expnd0\expndtw0\kerning0
. Do not remove this file after compilation, it may be useful for debugging. The basics of assembly language is taught in the exercises 12, so I don't mention all of them here. Otherwise you should find all the information needed about assembly language here. For you interest you may check the following links:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls3\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}{\field{\*\fldinst{HYPERLINK "http://linuxassembly.org/resources.html"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul Linux Assembly}}\expnd0\expndtw0\kerning0
\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}{\field{\*\fldinst{HYPERLINK "http://developer.intel.com/design/pentium/manuals/24319001.pdf"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul Intel Architecture Software Developer's Manual, Volume 1: Basic Architecture}}\expnd0\expndtw0\kerning0
\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}{\field{\*\fldinst{HYPERLINK "http://developer.intel.com/design/pentium/manuals/24319101.pdf"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul Intel Architecture Software Developer's Manual, Volume 2:
\b \expnd0\expndtw0\kerning0
 
\b0 \expnd0\expndtw0\kerning0
Volume 2: Instruction Set Reference Manual}}\expnd0\expndtw0\kerning0
\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}{\field{\*\fldinst{HYPERLINK "http://www.gnu.org/software/binutils/manual/gas-2.9.1/as.html"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul GNU Assembler: as manual}}\expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
At easiest you can compile and link assembly code using 
\i \expnd0\expndtw0\kerning0
gcc
\i0 \expnd0\expndtw0\kerning0
, which then calls 
\i \expnd0\expndtw0\kerning0
as
\i0 \expnd0\expndtw0\kerning0
 and linker (
\f1 \expnd0\expndtw0\kerning0
gcc -o program program.s
\f0 \expnd0\expndtw0\kerning0
). If 
\i \expnd0\expndtw0\kerning0
as
\i0 \expnd0\expndtw0\kerning0
 is used directly as \
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
as -o program.o program.s
\f0 \expnd0\expndtw0\kerning0
\
then some library files have to be included when linking the object code. The command is: \

\f1 \expnd0\expndtw0\kerning0
ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 /usr/lib/crt1.o /usr/lib/crti.o -lc 
\f3\i \expnd0\expndtw0\kerning0
program.o
\f1\i0 \expnd0\expndtw0\kerning0
 /usr/lib/crtn.o -o 
\f3\i \expnd0\expndtw0\kerning0
program
\f0\i0 \expnd0\expndtw0\kerning0
 \
(Tested in class 6325. Check for other environments.)\
Intel instruction set is very wide but we need only a few commands. All possible data types and registers are not needed, either. We use 32-bit operands as default. Here're some hints about assembler:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Assembly code can be divided into two subsections, which are enough for us: 
\i \expnd0\expndtw0\kerning0
data
\i0 \expnd0\expndtw0\kerning0
 and 
\i \expnd0\expndtw0\kerning0
text
\i0 \expnd0\expndtw0\kerning0
 subsections. In the 
\i \expnd0\expndtw0\kerning0
data
\i0 \expnd0\expndtw0\kerning0
 subsection all variables, their types, and initial values are defined. Following 32-bit data types are enough for us: 
\i \expnd0\expndtw0\kerning0
.int
\i0 \expnd0\expndtw0\kerning0
 and/or 
\i \expnd0\expndtw0\kerning0
.long
\i0 \expnd0\expndtw0\kerning0
 (for variables having type 
\i \expnd0\expndtw0\kerning0
int
\i0 \expnd0\expndtw0\kerning0
) and 
\i \expnd0\expndtw0\kerning0
.asciz
\i0 \expnd0\expndtw0\kerning0
 or 
\i \expnd0\expndtw0\kerning0
.string
\i0 \expnd0\expndtw0\kerning0
 for strings. In practise you print your symbol table in this section. The 
\i \expnd0\expndtw0\kerning0
text
\i0 \expnd0\expndtw0\kerning0
 section contains assembly command lines and labels, which are used in jumps. The execution of the commands goes sequentially line by line if there're are no jumps. The order of data and text parts is irrelevant.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The following opcodes are enough for us: 
\i \expnd0\expndtw0\kerning0
add, call, cdq, cmp, dec, idiv, imul, inc, jl, jg, jle, jge, je, jne, jmp, mov, neg, pop, push, ret
\i0 \expnd0\expndtw0\kerning0
 and 
\i \expnd0\expndtw0\kerning0
sub
\i0 \expnd0\expndtw0\kerning0
 - these opcodes are introduced later in the text. Usually a letter 
\i \expnd0\expndtw0\kerning0
l
\i0 \expnd0\expndtw0\kerning0
 is added at the end of these opcodes to mark the use of 32-bit operands, for example 
\i \expnd0\expndtw0\kerning0
addl
\i0 \expnd0\expndtw0\kerning0
. Though, suffix is optional when the size can be guessed from operands, and otherwise the default is 32 bits. There can be 0 to 3 operands, usually one or two. In the case of two operands the first one is the source and the second one is the destination. (In the Intel syntax it's otherway round!) Operands can be registers, variables or immediate integer numbers.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
32-bit general registers are 
\i \expnd0\expndtw0\kerning0
%eax, %ebx, %ecx, %edx, %esi, %edi, %ebp
\i0 \expnd0\expndtw0\kerning0
 and 
\i \expnd0\expndtw0\kerning0
%esp
\i0 \expnd0\expndtw0\kerning0
. It's probably wise to use only the first four, though at least 
\i \expnd0\expndtw0\kerning0
%ebp
\i0 \expnd0\expndtw0\kerning0
 and 
\i \expnd0\expndtw0\kerning0
%esp
\i0 \expnd0\expndtw0\kerning0
 are used to control the stack and it's not wise to loose their values. Note, that some opcodes and functions use these registers, too, so you cannot expect that a value stored in a register in the beginning of the program will be same in the end of the program. %eax, for example, is used to store the results of many operations. So, you have to use variables to store values, not registers.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Variables - or should I say named memory locations - have to be introduced in the data subsection to enable the use of them. Variables are referred by a plain variable name, not 
\i \expnd0\expndtw0\kerning0
$variable
\i0 \expnd0\expndtw0\kerning0
. Dollar sign and variable refers to the address of the variable, not to the value. This is needed, though, for example with 
\i \expnd0\expndtw0\kerning0
printf
\i0 \expnd0\expndtw0\kerning0
 function, when the address of the string is given for the function, not the string itself.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
When you use directly numbers in the assembler code, they have to be marked with 
\i \expnd0\expndtw0\kerning0
'$'
\i0 \expnd0\expndtw0\kerning0
 prefix, for example 
\i \expnd0\expndtw0\kerning0
$123
\i0 \expnd0\expndtw0\kerning0
.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
When using C libraries, you should take into account a few things: in the beginning of every function you should store stack pointer and stack frame pointer and return them in the end. So the first lines in your text subsection and consequently the last lines (excluding exiting the function) should be these: 
\f1 \expnd0\expndtw0\kerning0
	pushl	%ebp\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	movl	%esp, %ebp\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	pushl   %ebx\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
        pushl   %esi\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
        pushl   %edi\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
-------------------------------------\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	popl	%edi\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	popl	%esi\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	popl    %ebx\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	movl	%ebp, %esp\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	popl	%ebp\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
	/* Exiting with 
\f3\i \expnd0\expndtw0\kerning0
ret
\f1\i0 \expnd0\expndtw0\kerning0
 opcode or C's 
\f3\i \expnd0\expndtw0\kerning0
exit
\f1\i0 \expnd0\expndtw0\kerning0
 function - \uc0\u8232 	using 
\f3\i \expnd0\expndtw0\kerning0
ret
\f1\i0 \expnd0\expndtw0\kerning0
 requires updating the stack pointer when stack is used */\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\uc0\u8232 
\f0 \expnd0\expndtw0\kerning0
You need stack mainly with 
\i \expnd0\expndtw0\kerning0
printf
\i0 \expnd0\expndtw0\kerning0
 function, which can be used to implement functionality of 
\i \expnd0\expndtw0\kerning0
write/writeln
\i0 \expnd0\expndtw0\kerning0
 in Pascal. The parameters of the function are pushed into the stack before calling the function. Parameters are not removed from the stack after the call but you have to do it by yourself: per every parameter you should add 4 to the 
\i \expnd0\expndtw0\kerning0
%esp
\i0 \expnd0\expndtw0\kerning0
 register. (Every parameter is 32 bits aka 4 bytes.) It's not very probable that you would run out of stack with our small test programs, even if you wouldn't do this. \uc0\u8232 , but then your program (<i>main</i> function) isn't compatible with other C functions anymore. In this case you have to use <i>exit</i> function to end the program, you cannot return cleanly using <i>ret</i>, because the stack is out of date.</p>\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Syntax of assembler opcodes\
\pard\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
The opcodes needed are described here briefly, especially the use of operands. 
\i \expnd0\expndtw0\kerning0
imm32
\i0 \expnd0\expndtw0\kerning0
 means immediate integer value (32-bit), 
\i \expnd0\expndtw0\kerning0
r32
\i0 \expnd0\expndtw0\kerning0
 register (32-bit) ja 
\i \expnd0\expndtw0\kerning0
r/m32
\i0 \expnd0\expndtw0\kerning0
 either register or variable location in memory (32-bit). Of course, you can always move all operands into registers and do all operations using registers.\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Add
\b0 \expnd0\expndtw0\kerning0
 - adds the operands and stores the result into the latter operand\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
addl \'a0\'a0 imm32, r/m32\
addl \'a0\'a0 r32, r/m32\
addl \'a0\'a0 r/m32, r32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Call
\b0 \expnd0\expndtw0\kerning0
 - calls procedure/function (or system call) given as a parameter\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
call\'a0\'a0\'a0 printf\
call\'a0\'a0\'a0 exit
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Cdq
\b0 \expnd0\expndtw0\kerning0
 - need to be used with idiv (look at the example), to change double word to quadword\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
cdq
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Cmp
\b0 \expnd0\expndtw0\kerning0
 - compares two operands; the result is stored into a status register. After this command conditional jumps can be used though the trueness is checked from the status register.\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
cmpl\'a0\'a0\'a0 imm32, r/m32
\i0 \expnd0\expndtw0\kerning0
\

\i \expnd0\expndtw0\kerning0
cmpl \'a0\'a0 r32, r/m32\
cmpl \'a0\'a0 r/m32, r32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Dec
\b0 \expnd0\expndtw0\kerning0
 - decreases the operand by one\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
decl \'a0\'a0 r/m32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Idiv
\b0 \expnd0\expndtw0\kerning0
 - signed division. The divident is stored into the register 
\i \expnd0\expndtw0\kerning0
%eax
\i0 \expnd0\expndtw0\kerning0
 and then call 
\i \expnd0\expndtw0\kerning0
cdq
\i0 \expnd0\expndtw0\kerning0
 to get the sign extend into the register 
\i \expnd0\expndtw0\kerning0
%edx
\i0 \expnd0\expndtw0\kerning0
. The divisor is given as a parameter. The quotient is returned into the register 
\i \expnd0\expndtw0\kerning0
%eax
\i0 \expnd0\expndtw0\kerning0
 (and the remainder into 
\i \expnd0\expndtw0\kerning0
%edx
\i0 \expnd0\expndtw0\kerning0
).\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
idivl\'a0\'a0\'a0 r/m32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Imul
\b0 \expnd0\expndtw0\kerning0
 - signed multiplication. Parameters are multiplicated and the result is stored into register given as a second parameter.\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
imull \'a0\'a0 r/m32, r32\
imull\'a0\'a0\'a0 imm32, r32\
\
\pard\pardeftab720

\i0\b \cf2 \expnd0\expndtw0\kerning0
Inc
\b0 \expnd0\expndtw0\kerning0
 - increase the operand by one\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
incl \'a0\'a0 r/m32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Jl, jg, jle, jge, je, jne
\b0 \expnd0\expndtw0\kerning0
 - conditional jumps. The trueness is checked according the previous 
\i \expnd0\expndtw0\kerning0
cmp
\i0 \expnd0\expndtw0\kerning0
 command.\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
jCC \'a0\'a0 label
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Jmp
\b0 \expnd0\expndtw0\kerning0
 - unconditional jump\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
jmp\'a0\'a0\'a0 label
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Mov
\b0 \expnd0\expndtw0\kerning0
 - for moving values between memory and registers and storing integers values there\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
movl \'a0\'a0 r32, r/m32\
movl\'a0\'a0\'a0 r/m32, r32\
movl\'a0\'a0\'a0 imm32, r/m32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Neg
\b0 \expnd0\expndtw0\kerning0
 - negation\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
negl\'a0\'a0\'a0 r/m32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Pop
\b0 \expnd0\expndtw0\kerning0
 - popping parameters from the stack\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
popl\'a0\'a0\'a0 r/m32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Push
\b0 \expnd0\expndtw0\kerning0
 - pushing parameters into the stack\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
pushl\'a0\'a0\'a0 r/m32
\i0 \expnd0\expndtw0\kerning0
\

\i \expnd0\expndtw0\kerning0
pushl\'a0\'a0\'a0 imm32
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Ret
\b0 \expnd0\expndtw0\kerning0
 - return to the function or procedure which originally called this function; the return value can be forgotten although it exist in the syntax\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
ret
\i0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Sub
\b0 \expnd0\expndtw0\kerning0
 - first operand is subtracted from the second and the result is stored into the second operand\
\pard\pardeftab720

\i \cf2 \expnd0\expndtw0\kerning0
subl \'a0\'a0 imm32, r/m32\
subl \'a0\'a0 r32, r/m32\
subl \'a0\'a0 r/m32, r32
\i0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
Assembler from TAC\
\pard\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
Generating assembler from TAC commands is quite straightforward - here're some examples:\
\pard\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
(TAC_ADD,a,b,c):\
	fprintf(f,"\\t movl %s, %%eax\\n", getNameOrValue(a));\
        fprintf(f,"\\t addl %s, %%eax\\n", getNameOrValue(b));\
        fprintf(f,"\\t movl %%eax, %s\\n", getNameOrValue(c));\
(TAC_DIV,a,b,c)\
	fprintf(f,"\\t movl %s, %%eax\\n", getNameOrValue(a));\
	fprintf(f,"\\t cdq");\
        fprintf(f,"\\t movl %s, %%ebx\\n", getNameOrValue(b));\
        fprintf(f,"\\t idiv %%ebx\\n");\
        fprintf(f,"\\t movl %%eax, %s\\n", getNameOrValue(c));\
(TAC_JLE,a,b,c)\
	fprintf(f,"\\t movl %s, %%eax\\n", getNameOrValue(b));\
	fprintf(f,"\\t cmpl %s, %%eax\\n", getNameOrValue(a));\
	fprintf(f,"\\t jle %s", getNameOrValue(c));\
\pard\pardeftab720

\f0 \cf2 \expnd0\expndtw0\kerning0
Other TAC commands are transformed in the same way. Examples of the use of 
\i \expnd0\expndtw0\kerning0
printf
\i0 \expnd0\expndtw0\kerning0
 function can be found from exercise solutions.\
\pard\pardeftab720

\b \cf2 \cb3 \expnd0\expndtw0\kerning0
Hints\
\pard\pardeftab720

\b0 \cf2 \cb1 \expnd0\expndtw0\kerning0
As always, it's easier to manage larger software projects by dividing them into smaller parts. So, first write a lexer, which finds from the input the right tokens. Add syntactic rules to your parser, until it accepts the language. Add semantic actions gradually and finally generate the assembly code. For example, starting with semantic actions and code generation for writeln and assigment statements will give you an usable base for testing compilation of simple programs. Then adding new actions and testing them will be easy.}